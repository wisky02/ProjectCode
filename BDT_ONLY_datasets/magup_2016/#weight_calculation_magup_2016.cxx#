//Takes the BDT dataset and calculates the weight for each BDT value from the ratio of the number of D0 and D0BAR candidates for a given BDT value. This weight is then outputed via a TTree which w
#include <iostream>
#include <stdio.h>
#include <string>
#include <vector>
#include <algorithm>
#include "RooDataSet.h" 
#include "RooRealVar.h"
#include "RooAbsArg.h"
#include "math.h"
#include "RooProdPdf.h"
#include "RooAddPdf.h"
#include "RooGenericPdf.h"
#include "RooGaussian.h"
#include "RooBifurGauss.h"
#include "TFile.h"
#include "TH1D.h"
#include "TCanvas.h"
#include "TStyle.h"
#include "RooPlot.h"
void weight_calculation_magup_2016(){

  using namespace RooFit;
  gStyle->SetPalette(kBird);
  gStyle->SetOptStat(0);
  gStyle->SetOptTitle(0);
  using namespace std; 

  //                        Data Input                          //

  // Getting real data Delta Mass and D0 Mass
  TFile *_file0 = TFile::Open("/home/ppe/l/ldickson/MSci/detector_assymmetry_code/code_2_0_1_6/asymmetry_weighted_datasets/magup_2016/D0_Kpipi_magup_2016_asymm_weighted.root");

  // Defining dataset and variables D0_M and deltam
  RooDataSet* data_mass = (RooDataSet*) _file0->Get("data");
  const RooArgSet* deltam1 = data_mass->get(0);
  RooRealVar* deltam = (RooRealVar*)&(*deltam1)["deltam"];

  // Loading MC data for seeding fits
  TFile *_file_monte_var = TFile::Open("/home/ppe/l/ldickson/MSci/improving_fits_code/datasets/monte_vars_RAS.root");
  TObject * monte_TObject = _file_monte_var->Get("monte_var_values");
  RooArgSet* monte_vars = (RooArgSet*)&(*monte_TObject);
  RooRealVar* monte_cdel_1 = (RooRealVar*)&(*monte_vars)["monte_cdel_1"];

 

  //                          SIGNAL: SHAPE PARAMETER                             //


  // Creating guassians and bifurcated guassian signal pdfs for deltam 
  RooRealVar mean_del("mean_del","mean_del",monte_mean_del_float,140,150) ; 
  RooRealVar sigma_del("sigma_del","sigma_del",monte_sigma_del_float,0.,10.) ; 
  RooGaussian gauss_del("gauss_del","gauss_del",*deltam,mean_del,sigma_del) ; 

  RooRealVar mean_del2("mean_del2","mean_del2",monte_mean_del2_float,144,147) ; 
  RooRealVar sigma_del2("sigma_del2","sigma_del2",monte_sigma_del2_float,0.,10.) ; 
  RooGaussian gauss_del2("gauss_del2","gauss_del2",*deltam,mean_del2,sigma_del2) ;

  RooRealVar mean_bi("mean_bi","mean_bi",monte_mean_bi_float,140,150) ;
  RooRealVar sigma_L_bi("sigma_L_bi","sigma_L_bi",monte_sigma_L_bi_float,0.01,5) ;
  RooRealVar sigma_R_bi("sigma_R_bi","sigma_R_bi",monte_sigma_R_bi_float,0.01,5) ;
  RooBifurGauss gauss_del_bi("gauss_del_bi","gauss_del_bi",*deltam,mean_bi,sigma_L_bi, sigma_R_bi) ;

  // Total delta signal (two gaussians + bifurcated gaussian)
  RooRealVar cdel_1("cdel_1", "", 0.5, 0, 1) ;
  RooRealVar cdel_2("cdel_2", "", 0.5, 0, 1) ;
  RooAddPdf del_sig("del_sig","", RooArgList(gauss_del,gauss_del2,gauss_del_bi), RooArgList( cdel_1, cdel_2), true);


  //                    BACKGROUND: SHAPE PARAMETER                  // 


  // Deltam combinatorial background (modified exponential)
  RooRealVar M_th_del("M_th_del","M_th_del",139,170) ;
  M_th_del.setVal(139.57);   // pi plus/minus mass as threshold value
  M_th_del.setConstant(); 
  RooRealVar a_del("a_del","a_del",20,0,60) ;
  RooRealVar b_del("b_del","b_del", -20,-100,100) ;
  RooArgList(*deltam,M_th_del,a_del,b_del);
  RooGenericPdf bkg_del("bkg_del","Combinatorial Background plot","(1-exp(-(deltam-M_th_del)/a_del))*(deltam/M_th_del)^b_del",RooArgList(*deltam,M_th_del,a_del,b_del)) ;


  //                  COMBINING: SHAPE PARAMETER           //


  // Total signal (deltam: 2 gauss + bifurcated , D0: 2 gauss)
  RooProdPdf sig_pdf("sig_pdf","sig_pdf",RooArgSet(del_sig));

  // Total Combinatorial background (deltam: modified exponential , D0: straight line)
  RooProdPdf com_bkgpdf("com_bkgpdf","com_bkgpdf",RooArgSet(bkg_del));

  // Total Random pi background (deltam: modified exponential, D0: same gaussian as signal
  RooProdPdf ranpi_bkgpdf("ranpi_bkgpdf","ranpi_bkgpdf",RooArgSet(bkg_del));

  //Here the bkg_del pdf is used for both the random pi and combinatorial background


  //                   FINAL  PDF: SHAPE PARAMETER               //


  RooRealVar nsignal("nsignal", "", data_mass->numEntries()*0.3, 0, data_mass->numEntries()*1.5) ;
  RooRealVar n_com_bkg("n_com_bkg", "", data_mass->numEntries()*0.35, 0, data_mass->numEntries()*1.5) ;
  RooRealVar n_ranpi_bkg("n_ranpi_bkg", "", data_mass->numEntries()*0.35, 0, data_mass->numEntries()*1.5) ;

  // Sum of signal, random pi and combinatorial background components
  RooAddPdf totalpdf("totalpdf", "", RooArgList(sig_pdf, com_bkgpdf, ranpi_bkgpdf), RooArgList(nsignal, n_com_bkg,n_ranpi_bkg)) ;


  //                  FITTING AND PLOTTING: SHAPE PARAMETER              //


  //Fitting and printing plots
  totalpdf.fitTo(*data_mass,SumW2Error(kTRUE));

  auto c2 = new TCanvas();
  RooPlot* del_frame = deltam->frame();
  data_mass->plotOn(del_frame);
  totalpdf.plotOn(del_frame);

  totalpdf.Print("t"); //Print out each component of totalpdf
  totalpdf.plotOn(del_frame, Components("sig_pdf"), LineColor(kBlue), LineStyle(kDashed)) ;
  totalpdf.plotOn(del_frame, Components("gauss_del_bi"), LineColor(kCyan), LineStyle(kDashed)) ;
  totalpdf.plotOn(del_frame, Components("gauss_del"), LineColor(kGreen), LineStyle(kDashed)) ;
  totalpdf.plotOn(del_frame, Components("gauss_del2"), LineColor(kOrange), LineStyle(kDashed)) ;
  totalpdf.plotOn(del_frame, Components("com_bkgpdf"), LineColor(kMagenta), LineStyle(kDashed)) ;
  totalpdf.plotOn(del_frame, Components("ranpi_bkgpdf"), LineColor(kRed), LineStyle(kDashed)) ;
  del_frame->Draw();

TFile* deltam_fits_magup_2016 = new TFile("asymm_deltam_fits_magup_2016.root","RECREATE");
del_frame->Write();
deltam_fits_magup_2016->Close();
delete deltam_fits_magup_2016;


  //                    GETTING COMBINED DATA  + CREATING VARIABLE BINS                        //


  // Getting combined data for D0
  TFile *_file1 = TFile::Open("/home/ppe/l/ldickson/MSci/detector_assymmetry_code/code_2_0_1_6/asymmetry_weighted_datasets/magup_2016/D0_Kpipi_magup_2016_asymm_weighted.root ");
  // Defining dataset and variables D0_M, deltam and ctau for D0
  RooDataSet* data_D0_comb = (RooDataSet*) _file1->Get("data");
  const RooArgSet* variables_D0 = data_D0_comb->get(0);
  RooRealVar* ctau_D0 = (RooRealVar*)&(*variables_D0)["ctau"];
  RooRealVar* deltam_D0 = (RooRealVar*)&(*variables_D0)["deltam"];
  float ctau_float;
 
  // Getting combined data for D0_bar
  TFile *_file2 = TFile::Open("/home/ppe/l/ldickson/MSci/detector_assymmetry_code/code_2_0_1_6/asymmetry_weighted_datasets/magup_2016/D0BAR_Kpipi_magup_2016_asymm_weighted.root");

  // Defining dataset and variables D0_M, deltam and ctau for D0_bar
  RooDataSet* data_D0BAR_comb = (RooDataSet*) _file2->Get("data");
  const RooArgSet* variables_D0BAR = data_D0BAR_comb->get(0);
  RooRealVar* ctau_D0BAR = (RooRealVar*)&(*variables_D0BAR)["ctau"];
  RooRealVar* deltam_D0BAR = (RooRealVar*)&(*variables_D0BAR)["deltam"];
  float ctaubar_double;

  // Combining D0 and D0bar and sorting bins
 unsigned int entries_D0 =  data_D0_comb->numEntries() ;
 unsigned  int entries_D0bar =  data_D0BAR_comb->numEntries();
  vector<float> decaytimes_D0 ;
  vector<float> decaytimes_D0bar ;
  vector<float> decaytimes;
  float decaytime_D0 ;
  float decaytime_D0bar ;

  for(unsigned int i = 0 ; i < entries_D0 ; ++i){
    decaytime_D0 = ((RooRealVar*)&(*data_D0_comb->get(i))["ctau"])->getVal() ;
    decaytimes_D0.push_back(decaytime_D0) ;
  }
  
  for(unsigned int q = 0 ; q < entries_D0bar ; ++q){
    decaytime_D0bar = ((RooRealVar*)&(*data_D0BAR_comb->get(q))["ctau"])->getVal() ;
    decaytimes_D0bar.push_back(decaytime_D0bar) ;
  } 

  decaytimes_D0.insert( decaytimes_D0.end(), decaytimes_D0bar.begin(), decaytimes_D0bar.end() );


  decaytimes.reserve( decaytimes_D0.size() + decaytimes_D0bar.size() ); // preallocate memory
  decaytimes.insert( decaytimes.end(), decaytimes_D0.begin(), decaytimes_D0.end() );
  decaytimes.insert( decaytimes.end(), decaytimes_D0bar.begin(), decaytimes_D0bar.end() );
  sort(decaytimes.begin(), decaytimes.end()) ;
  
unsigned  int total_entries = decaytimes.size(); 
const unsigned  int number_bins = 10 ;
unsigned  int number_per_bin = total_entries/number_bins ;

  string decaytimes_str_D0;
  string decaytimes_str_D0bar;
  string decaytimes_str;
  vector<string> bin_edges;
  bin_edges.push_back(to_string(0.));
  //checks the number of data points within a bound as calculated above and produces ctau lower edge
  for (unsigned int j = 1 ; j < total_entries+1 ; j++){
    if (j % number_per_bin == 0.) { 
      decaytimes_str =to_string(decaytimes[j]);
      bin_edges.push_back(decaytimes_str);
    }
    else{ continue; }
  }

  //                 COMBINING/SORTING VECTORS AND CREATING VARIABLE BINS                 //

  //Creating strings for D0 reduced dataset cuts
  vector<string> bin_string_vect;
  string bin_str1;
  string bin_str2;
  string bin_str3;
  string bin_str4;
  string bin_str5;
  string total_bin_str;

  //D0
  for(unsigned int m = 0; m<bin_edges.size() -1; m++){
    bin_str1 =  "ctau>= ";
    bin_str2 =  bin_edges[m] ; 
    bin_str3 = " && " ;
    bin_str4 = "ctau <" ;
    bin_str5 =bin_edges[m+1] ;
    total_bin_str = bin_str1 + bin_str2 + bin_str3 + bin_str4 + bin_str5;
    bin_string_vect.push_back(total_bin_str) ;
  }

  //D0bar
  vector<string>bin_string_vect_bar;
  for(unsigned int m = 0; m<bin_edges.size() -1; m++){
    bin_str1 =  "ctau>= ";
    bin_str2 =  bin_edges[m] ; 
    bin_str3 = " && " ;
    bin_str4 = "ctau <" ;
    bin_str5 =bin_edges[m+1] ;
    total_bin_str = bin_str1 + bin_str2 + bin_str3 + bin_str4 + bin_str5;
    bin_string_vect_bar.push_back(total_bin_str) ;
  }

  //D0 reduce data sets
  vector<RooDataSet*> dataset_d0_vect;
  const char* bin_char;  
 
  for(unsigned int kl = 0; kl<number_bins ; kl++){
    bin_char = bin_string_vect[kl].c_str();
    RooDataSet* d1 = (RooDataSet*) data_D0_comb->reduce(RooArgSet(*deltam_D0, *ctau_D0),bin_char);
    dataset_d0_vect.push_back(d1);
  }

  //D0bar reduced datasets
  vector<RooDataSet*> dataset_d0bar_vect;
  for(unsigned int ky = 0; ky<number_bins  ; ky++){
    bin_char = bin_string_vect_bar[ky].c_str();
    RooDataSet* d1 = (RooDataSet*) data_D0BAR_comb->reduce(RooArgSet(*deltam_D0BAR, *ctau_D0BAR),bin_char);
    dataset_d0bar_vect.push_back(d1);
  }

  //                    SETTING SHAPE PARAMETERS CONSTANT                          //


  // loading variable's data created from fit
  RooArgSet* totalpdf_vars = totalpdf.getParameters(*data_mass);

  // assinging variable values to constant. Signal/background variables left to vary

  // -- Signal Shape Delta mass--
 
  ((RooRealVar*)&(*totalpdf_vars)["mean_del"])->setConstant() ;
  ((RooRealVar*)&(*totalpdf_vars)["mean_del2"])->setConstant() ;
  ((RooRealVar*)&(*totalpdf_vars)["mean_bi"])->setConstant() ;
  ((RooRealVar*)&(*totalpdf_vars)["sigma_del"])->setConstant() ;
  ((RooRealVar*)&(*totalpdf_vars)["sigma_del2"])->setConstant() ;
  ((RooRealVar*)&(*totalpdf_vars)["sigma_L_bi"])->setConstant() ;
  ((RooRealVar*)&(*totalpdf_vars)["sigma_R_bi"])->setConstant() ;
  ((RooRealVar*)&(*totalpdf_vars)["cdel_1"])->setConstant() ;
  ((RooRealVar*)&(*totalpdf_vars)["cdel_2"])->setConstant() ;
  

  // --Background Shape -- 
  // ((RooRealVar*)&(*totalpdf_vars)["M_th_del"])->setConstant() ; already set constant earlier
  ((RooRealVar*)&(*totalpdf_vars)["a_del"])->setConstant() ;
  ((RooRealVar*)&(*totalpdf_vars)["b_del"])->setConstant() ;

  // -- Signal Value --
 // total_nsignal

  // -- Background Value --
 //total_com_bkg
 //total_ranpi_bkg


  //                    FITTING NEW TIME-DEPENDANT SIGNAL VALUES AND PUTTING INTO VECTOR                            //


  // D0 decay time itteration over subdatasets from vector
  int k;
  int data_d0_size=dataset_d0_vect.size(); 
  RooRealVar *nsignal_vals_D0 ;
  vector<double> nsignal_D0_vect_double;
  vector<double> nsignal_D0_error_vect_double;
  RooAbsArg* coefficient;
  double nsignal_D0_double;
  double nsignal_D0_error_double;
  RooArgSet* totalpdf_signalvars;
  string title_str;
  const char* title_str_char;
  string loop_str; 
  string file_str;
  const char* file_str_char;
  
// Creating file for saving time dependent fits for D0  
TFile* td_D0_up_16 = new TFile("asymm_time_dependent_D0_deltam_magup_2016.root","RECREATE");

for (k=0; k<data_d0_size; k++) {
    totalpdf.fitTo(*dataset_d0_vect[k]);    
    loop_str = to_string(k);
    title_str = "time dependent D0 deltam" + loop_str;
    title_str_char = title_str.c_str();
    file_str = "D0_time_dependence_deltam" + loop_str;
    file_str_char = file_str.c_str();
    
    // auto canvas_D0 = new TCanvas();
    RooPlot* del_D0_td_frame = deltam_D0->frame(Title(file_str_char));
    dataset_d0_vect[k]->plotOn(del_D0_td_frame);
    totalpdf.plotOn(del_D0_td_frame);
    del_D0_td_frame->Write(file_str_char);

    totalpdf_signalvars = totalpdf.getParameters(*dataset_d0bar_vect[k]);
    nsignal_D0_double = nsignal.getVal();
    nsignal_D0_error_double = nsignal.getError();
    nsignal_D0_vect_double.push_back(nsignal_D0_double);
    nsignal_D0_error_vect_double.push_back(nsignal_D0_error_double);

    //   canvas_D0->Close();
 }
td_D0_up_16->Close();
delete td_D0_up_16;


 //D0_bar decay time itteration over subdatasets from vector
  int p; 
  int data_D0bar_size = dataset_d0bar_vect.size();
  RooRealVar *nsignal_vals_D0bar ;
  vector<double> nsignal_D0bar_vect_double;
  vector<double> nsignal_D0bar_error_vect_double;
  double nsignal_D0bar_double;
  double nsignal_D0bar_error_double;
  RooArgSet* totalpdf_signalvars_BAR;
  string title_str_BAR;
  const char* title_str_char_BAR;
  string loop_str_BAR;
  string file_str_BAR;
  const char* file_str_char_BAR;

// Creating file for saving time dependent fits for D0BAR
TFile* td_D0BAR_up_16 = new TFile("asymm_time_dependent_D0BAR_deltam_magup_2016.root","RECREATE");

  for (p=0; p<data_D0bar_size; p++) {
    totalpdf.fitTo(*dataset_d0bar_vect[p]);
    loop_str_BAR = to_string(p);
    title_str_BAR = "time dependent D0BAR deltam" + loop_str; 
    title_str_char_BAR = title_str_BAR.c_str();
    file_str_BAR = "D0BAR_time_dependence_deltam" + loop_str;
    file_str_char_BAR = file_str_BAR.c_str();
    
    // auto canvas_D0BAR = new TCanvas();
    RooPlot* del_D0BAR_td_frame = deltam_D0BAR->frame(Title(file_str_char_BAR));
    dataset_d0bar_vect[p]->plotOn(del_D0BAR_td_frame);
    totalpdf.plotOn(del_D0BAR_td_frame);
    del_D0BAR_td_frame->Write(file_str_char_BAR);

    totalpdf_signalvars_BAR = totalpdf.getParameters(*dataset_d0bar_vect[p]);
    nsignal_D0bar_double = nsignal.getVal();
    nsignal_D0bar_error_double = nsignal.getError();
    nsignal_D0bar_vect_double.push_back(nsignal_D0bar_double);
    nsignal_D0bar_error_vect_double.push_back(nsignal_D0bar_error_double);
    
    //  canvas_D0->Close();
  }
td_D0BAR_up_16->Close();
delete td_D0BAR_up_16;


  //                 PLOTTING DATA ON HIST              //
 
//  D0  and D0bar  //
  
   	vector <Float_t> edge_vector;
	Double_t edge;
	Float_t edge_float;
	const char* bin_edge_char;
	for (unsigned int z=0; z<bin_edges.size();z++){
		bin_edge_char = bin_edges[z].c_str();
		edge = atof(bin_edge_char);
		edge_float = (const Float_t) edge;
		edge_vector.push_back(edge);
	}


  TH1D* D0_sig_hist = new TH1D("D0_sig_hist","D0 signal hist", number_bins, &edge_vector[0]); 
  TH1D* D0bar_sig_hist = new TH1D("D0bar_sig_hist","D0 BAR signal hist", number_bins, &edge_vector[0]);
  D0_sig_hist->Sumw2();
  D0bar_sig_hist->Sumw2();

  for (unsigned int q=0; q<number_bins; q++) {
    // D0 //
    nsignal_D0_double = nsignal_D0_vect_double[q];
    D0_sig_hist->SetBinContent(q+1,nsignal_D0_double);

    // D0 BAR //
    nsignal_D0bar_double = nsignal_D0bar_vect_double[q];
    D0bar_sig_hist->SetBinContent(q+1,nsignal_D0bar_double);		     
  }  

  auto c6 =  new TCanvas();
  D0_sig_hist->Draw();

  auto c7 = new TCanvas();
  D0bar_sig_hist->Draw();

  TH1D *h3 = (TH1D*)D0_sig_hist->Clone("h3");
  TH1D *h4 = (TH1D*)D0_sig_hist->Clone("h4");
  h3->Add(D0bar_sig_hist,-1);
  h4->Add(D0bar_sig_hist);
  h3->Divide(h4);


  //     CALCULATING ERRORS     //
  

//err = sqrt( errD0^2*(dD0(f))^2 + errD0bar^2*(dD0bar(f))^2 )

  int u;  
  double dD0_denom;
  double dD0_numer;
  double dD0_differential;
  double dD0_term1;
  double dD0bar_denom;
  double dD0bar_numer;
  double dD0bar_differential;
  double dD0bar_term2;
  double error_square_sum;
  vector<double> error_vect;
  for (u=0; u<data_d0_size; u++) {
    // D0 partial differntial squared  
    dD0_numer = 4*pow(nsignal_D0bar_vect_double[u],2);
    dD0_denom = pow(nsignal_D0_vect_double[u]+ nsignal_D0bar_vect_double[u],4);
    dD0_differential = dD0_numer/dD0_denom;
    dD0_term1 = dD0_differential*pow(nsignal_D0_error_vect_double[u],2);

    //D0bar partial differential squared
    dD0bar_numer = 4*pow(nsignal_D0_vect_double[u],2);
    dD0bar_denom = pow(nsignal_D0_vect_double[u]+ nsignal_D0bar_vect_double[u],4);
    dD0bar_differential = dD0bar_numer/dD0bar_denom;
    dD0bar_term2 =  dD0bar_differential*pow(nsignal_D0bar_error_vect_double[u],2);

    // Total error
    error_square_sum = sqrt(dD0_term1+dD0bar_term2);
    error_vect.push_back(error_square_sum);
    h3->SetBinError(u+1 , error_square_sum);
  }

  auto c8 = new TCanvas();
  h3->Draw();

 TFile* hist_file = new TFile("asymm_hist_magup_2016.root","RECREATE");
  h3->Write();
  hist_file->Close();
  delete hist_file;


}
